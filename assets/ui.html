<html>

<head>
    <link rel="stylesheet" type="text/css" href="ui.css">
    <link rel="stylesheet" type="text/css" href="chrome-tabs.css">
    <script src="ui.js"></script>
    <script src="anchorme.js"></script>
</head>

<body>
    <div class="chrome-tabs" data-chrome-tabs-instance-id="0">
        <div class="chrome-tabs-content">
            <button id="chrome-tabs-add-tab" class="chrome-tabs-add-tab" aria-label="New Tab"></button>
        </div>
        <div class="chrome-tabs-bottom-bar" style="z-index: 3;"></div>
    </div>

    <svg style="display: none;">
        <defs>
            <g id="svg_arrow_back">
                <path d="M427 277v-42h-260l119 -120l-30 -30l-171 171l171 171l30 -30l-119 -120h260z" />
            </g>
            <g id="svg_arrow_forward">
                <path d="M256 427l171 -171l-171 -171l-30 30l119 120h-260v42h260l-119 120z" />
            </g>
            <g id="svg_refresh">
                <path transform="matrix(1 0 0 -1 0 512)"
                    d="M377 377l50 50v-150h-150l69 69c-23 23 -55 38 -90 38c-71 0 -128 -57 -128 -128s57 -128 128 -128c56 0 104 35 121 85h44c-19 -74 -85 -128 -165 -128c-94 0 -170 77 -170 171s76 171 170 171c47 0 90 -19 121 -50z" />
            </g>
            <g id="svg_stop">
                <path
                    d="M405 375l-119 -119l119 -119l-30 -30l-119 119l-119 -119l-30 30l119 119l-119 119l30 30l119 -119l119 119z" />
            </g>
            <g id="svg_tools">
                <path
                    d="M22.7 19l-9.1-9.1c.9-2.3.4-5-1.5-6.9-2-2-5-2.4-7.4-1.3L9 6 6 9 1.6 4.7C.4 7.1.9 10.1 2.9 12.1c1.9 1.9 4.6 2.4 6.9 1.5l9.1 9.1c.4.4 1 .4 1.4 0l2.3-2.3c.5-.4.5-1.1.1-1.4z" />
            </g>
        </defs>
    </svg>

    <div id="bar">
        <span id="back" class="icon disabled">
            <svg viewBox="0 0 512 512" width="20" height="20">
                <use xlink:href="#svg_arrow_back" />
            </svg>
        </span>
        <span id="forward" class="icon disabled">
            <svg viewBox="0 0 512 512" width="20" height="20">
                <use xlink:href="#svg_arrow_forward" />
            </svg>
        </span>
        <span id="refresh" class="icon">
            <svg viewBox="0 0 512 512" width="20" height="20">
                <use xlink:href="#svg_refresh" />
            </svg>
        </span>
        <span id="stop" class="icon" style="display: none;">
            <svg viewBox="0 0 512 512" width="20" height="20">
                <use xlink:href="#svg_stop" />
            </svg>
        </span>
        <input onfocus="select_next_mouseup = true;"
            onmouseup="if (select_next_mouseup) this.select(); select_next_mouseup = false;" type="text"
            id="address"></input>
        <span id="toggle-tools" class="icon" role="button" tabindex="0" aria-label="Toggle inspector" data-tooltip="Inspector">
            <svg viewBox="0 0 24 24" width="18" height="18">
                <use xlink:href="#svg_tools" />
            </svg>
        </span>
        <span id="toggle-adblock" class="icon" role="button" tabindex="0" aria-pressed="true"
            aria-label="Toggle ad blocking" data-tooltip="Adblock">
            <!-- simple shield icon -->
            <svg viewBox="0 0 24 24" width="18" height="18">
                <path d="M12 2l7 3v5c0 5-3.4 9.7-7 11-3.6-1.3-7-6-7-11V5l7-3z" fill="currentColor" />
            </svg>
        </span>
        <span id="toggle-downloads" class="icon" role="button" tabindex="0" aria-label="View downloads"
            data-tooltip="Downloads">
            <svg viewBox="0 0 24 24" width="18" height="18" aria-hidden="true">
                <path d="M12 21l-6-6h4V3h4v12h4l-6 6z" fill="currentColor" />
            </svg>
            <span id="downloads-badge" class="downloads-badge"></span>
        </span>
        <!-- Overflow menu (three dots) -->
        <span id="toggle-menu" class="icon" role="button" tabindex="0" aria-label="Open menu"
            aria-haspopup="true" data-tooltip="Menu">
            <svg viewBox="0 0 24 24" width="18" height="18" aria-hidden="true">
                <circle cx="5" cy="12" r="2" fill="currentColor"></circle>
                <circle cx="12" cy="12" r="2" fill="currentColor"></circle>
                <circle cx="19" cy="12" r="2" fill="currentColor"></circle>
            </svg>
        </span>
    </div>

    <!-- Dropdown Menu -->
    <div id="menu-dropdown" class="menu-dropdown hidden" role="menu" aria-hidden="true">
        <div class="menu-item" data-action="new-tab">New tab [Ctrl+T]</div>
        <div class="menu-item" data-action="new-window">New window [Ctrl+N]</div>
        <div class="menu-separator"></div>
        <div class="menu-item" data-action="history">History</div>
        <div class="menu-item" data-action="downloads">Downloads</div>
    </div>

    <script src="draggabilly.pkgd.min.js"></script>
    <script src="chrome-tabs.js"></script>
    <script>
        var el = document.querySelector('.chrome-tabs')
        var chromeTabs = new ChromeTabs()
        var select_next_mouseup = false;
        var defaultFavicon = "earth.svg";
        var suggEl = null;
        var suggActiveIndex = -1;
        var suggOverlayOpen = false;

        chromeTabs.init(el, {
            tabOverlapDistance: 6,
            minWidth: 45,
            maxWidth: 243
        })

        function addTab(id, title, faviconUrl, isLoading) {
            const icon = (typeof faviconUrl === 'string' && faviconUrl.length > 0) ? faviconUrl : defaultFavicon;
            chromeTabs.addTab({ id: id, title: title, favicon: icon, loading: isLoading });
        }

        function updateTab(id, title, faviconUrl, isLoading) {
            const tab = document.querySelector("[data-tab-id='" + id + "']");
            const icon = (typeof faviconUrl === 'string' && faviconUrl.length > 0) ? faviconUrl : defaultFavicon;
            if (tab)
                chromeTabs.updateTab(tab, { title: title, favicon: icon, loading: isLoading });
        }

        function closeTab(id) {
            const tab = document.querySelector("[data-tab-id='" + id + "']");
            if (tab)
                chromeTabs.removeTab(tab);
        }

        function bindCallbacks() {
            el.addEventListener('requestNewTab', ({ detail }) => OnRequestNewTab());
            el.addEventListener('requestTabClose', ({ detail }) => OnRequestTabClose(detail.tabEl.getAttribute('data-tab-id')));
            el.addEventListener('activeTabChange', ({ detail }) => OnActiveTabChange(detail.tabEl.getAttribute('data-tab-id')));
            document.querySelector('#back').addEventListener('click', event => OnBack());
            document.querySelector('#forward').addEventListener('click', event => OnForward());
            document.querySelector('#refresh').addEventListener('click', event => OnRefresh());
            document.querySelector('#stop').addEventListener('click', event => OnStop());
            const inspectorBtn = document.querySelector('#toggle-tools');
            if (inspectorBtn) {
                const toggleInspector = () => { if (window.OnToggleTools) OnToggleTools(); };
                inspectorBtn.addEventListener('click', event => {
                    event.stopPropagation();
                    toggleInspector();
                });
                inspectorBtn.addEventListener('keydown', event => {
                    if (event.key === 'Enter' || event.key === ' ') {
                        event.preventDefault();
                        toggleInspector();
                    }
                });
            }
            const abBtn = document.querySelector('#toggle-adblock');
            if (abBtn) {
                const toggleAdblock = () => { if (window.OnToggleAdblock) OnToggleAdblock(); };
                abBtn.addEventListener('click', event => {
                    event.stopPropagation();
                    toggleAdblock();
                });
                abBtn.addEventListener('keydown', event => {
                    if (event.key === 'Enter' || event.key === ' ') {
                        event.preventDefault();
                        toggleAdblock();
                    }
                });
                try {
                    if (typeof GetAdblockEnabled === 'function') {
                        updateAdblockEnabled(!!GetAdblockEnabled());
                    } else {
                        updateAdblockEnabled(true);
                    }
                } catch (e) {
                    updateAdblockEnabled(true);
                }
            }
            const downloadsBtn = document.querySelector('#toggle-downloads');
            if (downloadsBtn) {
                const toggleDownloads = () => {
                    if (window.OnDownloadsOverlayToggle) OnDownloadsOverlayToggle();
                };
                downloadsBtn.addEventListener('click', event => {
                    event.stopPropagation();
                    toggleDownloads();
                });
                downloadsBtn.addEventListener('keydown', event => {
                    if (event.key === 'Enter' || event.key === ' ') {
                        event.preventDefault();
                        toggleDownloads();
                    }
                });
            }
            var address = document.querySelector('#address');
            address.onkeypress = (function (e) {
                if (e.which == '13') {
                    if (suggOverlayOpen) { e.preventDefault(); return false; }
                    address.blur();
                    let url = address.value;
                    if (anchorme.validate.url(url) || anchorme.validate.ip(url)) {
                        if (url.toLowerCase().startsWith("http://") || url.toLowerCase().startsWith("https://")) {
                            OnAddressBarNavigate(url);
                        } else {
                            OnAddressBarNavigate("http://" + url);
                        }
                    } else if (url.toLowerCase().startsWith("file:///")) {
                        OnAddressBarNavigate(url);
                    } else if (url.toLowerCase().startsWith("file://")) {
                        OnAddressBarNavigate("file:///" + url.substring(7));
                    } else {
                        // Interpret as search
                        OnAddressBarNavigate("https://www.google.com/search?q=" + encodeURIComponent(url));
                    }

                    return false;
                }
            });

            // Suggestions now use a native overlay (like menu/context menu) to avoid clipping.

            // Debounce helper
            let suggTimer = null;
            function scheduleSuggest() {
                if (suggTimer) clearTimeout(suggTimer);
                suggTimer = setTimeout(updateSuggestions, 80);
            }

            function hideSuggestions() {
                suggActiveIndex = -1;
                if (typeof CloseSuggestionsOverlay === 'function') CloseSuggestionsOverlay();
                if (typeof OnSuggestClose === 'function') OnSuggestClose();
                suggOverlayOpen = false;
            }

            function showSuggestions(items) {
                if (!items || !items.length) { hideSuggestions(); return; }
                const r = address.getBoundingClientRect();
                // Request temporary UI overlay growth so the panel isn't clipped
                const rows = items.length;
                const desired = Math.min(320, Math.max(120, 30 * rows + 12));
                if (typeof OnSuggestOpen === 'function') OnSuggestOpen(desired);
                // Ask native to show overlay with these items positioned under address bar
                const json = JSON.stringify(items);
                if (typeof OpenSuggestionsOverlay === 'function') {
                    OpenSuggestionsOverlay(Math.round(r.left), Math.round(r.bottom + 4), Math.round(r.width), json);
                }
                suggOverlayOpen = true;
            }

            function commitSuggestion(text) {
                if (!text) return;
                address.value = text;
                hideSuggestions();
                // trigger navigation same as pressing Enter
                if (window.OnAddressBarNavigate) {
                    let url = text;
                    if (anchorme.validate.url(url) || anchorme.validate.ip(url)) {
                        if (url.toLowerCase().startsWith("http://") || url.toLowerCase().startsWith("https://")) {
                            OnAddressBarNavigate(url);
                        } else {
                            OnAddressBarNavigate("http://" + url);
                        }
                    } else {
                        OnAddressBarNavigate("https://www.google.com/search?q=" + encodeURIComponent(url));
                    }
                }
            }

            function renderSuggestions(items) { suggActiveIndex = -1; showSuggestions(items); }

            function updateSuggestions() {
                const q = address.value.trim();
                if (!q) { hideSuggestions(); return; }
                try {
                    if (typeof GetSuggestions === 'function') {
                        const raw = GetSuggestions(q, 10);
                        let arr = [];
                        if (typeof raw === 'string') arr = JSON.parse(raw);
                        else if (Array.isArray(raw)) arr = raw;
                        renderSuggestions(arr || []);
                    } else {
                        hideSuggestions();
                    }
                } catch (e) {
                    hideSuggestions();
                }
            }

            // Events for suggestions
            address.addEventListener('input', () => { scheduleSuggest(); });
            address.addEventListener('focus', () => { if (address.value.trim()) { scheduleSuggest(); } });
            address.addEventListener('blur', () => { setTimeout(hideSuggestions, 50); });
            window.addEventListener('resize', () => { /* overlay will be closed and reopened on input change */ });

            address.addEventListener('keydown', (e) => {
                if (suggEl.style.display !== 'block') return;
                const total = suggEl.children.length;
                if (e.key === 'ArrowDown' && total) {
                    e.preventDefault();
                    suggActiveIndex = (suggActiveIndex + 1 + total) % total;
                    Array.from(suggEl.children).forEach((c, i) => c.classList.toggle('active', i === suggActiveIndex));
                } else if (e.key === 'ArrowUp' && total) {
                    e.preventDefault();
                    suggActiveIndex = (suggActiveIndex - 1 + total) % total;
                    Array.from(suggEl.children).forEach((c, i) => c.classList.toggle('active', i === suggActiveIndex));
                } else if (e.key === 'Enter') {
                    // Let Enter flow to existing navigation logic; overlay will be closed by blur/commit.
                } else if (e.key === 'Escape') {
                    hideSuggestions();
                }
            });
        }

        bindCallbacks();

        // Menu dropdown logic
        (function initMenu() {
            const toggleBtn = document.getElementById('toggle-menu');
            const menu = document.getElementById('menu-dropdown');

            function openMenu() {
                // Use native overlay instead of inline dropdown
                if (toggleBtn) toggleBtn.setAttribute('aria-expanded', 'true');
                if (window.OnMenuOpen) OnMenuOpen();
            }
            function closeMenu() {
                if (toggleBtn) toggleBtn.setAttribute('aria-expanded', 'false');
                if (window.OnMenuClose) OnMenuClose();
            }
            function isMenuOpen() {
                return menu && !menu.classList.contains('hidden');
            }

            if (toggleBtn) {
                toggleBtn.setAttribute('aria-expanded', 'false');
                toggleBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    openMenu();
                });
                toggleBtn.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        openMenu();
                    }
                });
            }

            // Handle menu item clicks
            // Inline menu is no longer used; actions handled by menu overlay

            // Close on outside click
            document.addEventListener('click', (e) => {
                const within = e.target.closest('#toggle-menu');
                if (!within) closeMenu();
            });

            // Close on Escape
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && isMenuOpen()) closeMenu();
            });
        })();

        (function initDownloadsPreview() {
            const toggleBtn = document.getElementById('toggle-downloads');
            const badge = document.getElementById('downloads-badge');

            function closePanel() {
                if (window.OnDownloadsOverlayClose) OnDownloadsOverlayClose();
            }

            document.addEventListener('click', (e) => {
                if (!e.target.closest('#toggle-downloads')) closePanel();
            });

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') closePanel();
            });

            function updateBadge() {
                if (!toggleBtn || !badge) return;
                try {
                    if (typeof GetDownloadsSnapshot === 'function') {
                        const raw = GetDownloadsSnapshot();
                        const data = JSON.parse(raw || '{"items":[]}');
                        const items = Array.isArray(data.items) ? data.items : [];
                        const active = items.filter(item => item.status === 'in-progress' || item.status === 'requested').length;
                        if (active > 0) {
                            badge.textContent = active > 9 ? '9+' : String(active);
                            toggleBtn.classList.add('badge-visible');
                        } else {
                            toggleBtn.classList.remove('badge-visible');
                        }
                    }
                } catch (e) {
                    toggleBtn.classList.remove('badge-visible');
                }
            }

            window.__ul_update_downloads_badge = updateBadge;
            updateBadge();
            setInterval(updateBadge, 2000);
        })();

        (function initToolbarTooltips() {
            const targets = document.querySelectorAll('[data-tooltip]');
            if (!targets || !targets.length) return;
            const tooltip = document.createElement('div');
            tooltip.id = 'toolbar-tooltip';
            tooltip.className = 'toolbar-tooltip';
            tooltip.setAttribute('role', 'tooltip');
            tooltip.style.visibility = 'hidden';
            document.body.appendChild(tooltip);

            let hideTimer = null;
            let currentTarget = null;

            function show(target) {
                if (!target) return;
                if (hideTimer) {
                    clearTimeout(hideTimer);
                    hideTimer = null;
                }
                const text = target.getAttribute('data-tooltip');
                if (!text) return;
                currentTarget = target;
                tooltip.textContent = text;
                tooltip.classList.remove('below');
                tooltip.classList.add('visible');
                tooltip.style.visibility = 'hidden';

                requestAnimationFrame(() => {
                    if (currentTarget !== target) return;
                    const rect = target.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const clampedX = Math.min(window.innerWidth - 12, Math.max(12, centerX));
                    tooltip.style.left = Math.round(clampedX) + 'px';

                    const tipRect = tooltip.getBoundingClientRect();
                    let top = rect.top - tipRect.height - 10;
                    let placeBelow = false;
                    if (top < 6) {
                        top = rect.bottom + 10;
                        placeBelow = true;
                    }
                    if (placeBelow && top + tipRect.height > window.innerHeight - 6) {
                        top = Math.max(6, window.innerHeight - tipRect.height - 6);
                    }
                    tooltip.classList.toggle('below', placeBelow);
                    tooltip.style.top = Math.round(top) + 'px';
                    tooltip.style.visibility = 'visible';
                });
            }

            function hide(immediate) {
                if (hideTimer) {
                    clearTimeout(hideTimer);
                    hideTimer = null;
                }
                const finish = () => {
                    currentTarget = null;
                    tooltip.classList.remove('visible');
                    tooltip.classList.remove('below');
                    tooltip.style.visibility = 'hidden';
                };
                if (immediate) {
                    finish();
                    return;
                }
                hideTimer = setTimeout(finish, 100);
            }

            targets.forEach(target => {
                target.addEventListener('mouseenter', () => show(target));
                target.addEventListener('mouseleave', () => hide(false));
                target.addEventListener('focus', () => show(target));
                target.addEventListener('blur', () => hide(false));
            });

            document.addEventListener('mousedown', () => hide(true));
            window.addEventListener('scroll', () => hide(true));
            window.addEventListener('resize', () => hide(true));
        })();
    </script>
</body>

</html>